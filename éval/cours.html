<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üìö Cours - Three.js, Shaders & Physique</title>
    <link rel="stylesheet" href="style.css">
    <style>
        .course-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .chapter {
            background: white;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .chapter h2 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .chapter h3 {
            color: #3498db;
            margin-top: 25px;
        }
        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
        }
        .highlight {
            background: #fff3cd;
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
        }
        .tip {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .warning {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .nav-menu {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        .nav-menu a {
            display: block;
            padding: 8px 15px;
            color: #3498db;
            text-decoration: none;
            border-radius: 5px;
            margin: 5px 0;
            transition: all 0.3s;
        }
        .nav-menu a:hover {
            background: #3498db;
            color: white;
        }
        ul li {
            margin: 10px 0;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="course-container">
        <header style="text-align: center; margin-bottom: 40px;">
            <h1>üìö Guide de R√©vision Complet</h1>
            <p style="font-size: 1.2em; color: #666;">Three.js, Shaders WebGL & Physique Cannon.js</p>
            <a href="index.html" style="display: inline-block; margin-top: 20px; padding: 10px 30px; background: #3498db; color: white; text-decoration: none; border-radius: 5px;">üéì Passer au QCM</a>
        </header>

        <div class="nav-menu">
            <h3>üìë Sommaire</h3>
            <a href="#chapitre1">1. Three.js - Fondamentaux</a>
            <a href="#chapitre2">2. Syst√®mes de Particules</a>
            <a href="#chapitre3">3. Shaders WebGL</a>
            <a href="#chapitre4">4. Physique avec Cannon.js</a>
            <a href="#chapitre5">5. Optimisation & Performance</a>
            <a href="#chapitre6">6. Debugging & Bonnes Pratiques</a>
        </div>

        <!-- CHAPITRE 1 -->
        <div class="chapter" id="chapitre1">
            <h2>1. Three.js - Fondamentaux</h2>
            
            <h3>üé¨ Architecture de Base</h3>
            <p>Une application Three.js repose sur <strong>3 √©l√©ments essentiels</strong> :</p>
            <ul>
                <li><span class="highlight">Scene</span> : Conteneur de tous les objets 3D</li>
                <li><span class="highlight">Camera</span> : Point de vue (PerspectiveCamera ou OrthographicCamera)</li>
                <li><span class="highlight">Renderer</span> : Moteur de rendu WebGL</li>
            </ul>

            <div class="code-block">// Structure de base
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, width/height, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();

// Boucle d'animation
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}</div>

            <h3>üì¶ Cr√©er un Objet 3D</h3>
            <p>Un objet 3D (Mesh) = <strong>Geometry + Material</strong></p>
            
            <div class="code-block">// G√©om√©trie (forme)
const geometry = new THREE.BoxGeometry(1, 1, 1);

// Mat√©riau (apparence)
const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });

// Mesh (objet final)
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);</div>

            <h3>üí° Types de Mat√©riaux</h3>
            <ul>
                <li><strong>MeshBasicMaterial</strong> : Pas d'√©clairage, couleur uniforme (rapide)</li>
                <li><strong>MeshLambertMaterial</strong> : √âclairage diffus simple</li>
                <li><strong>MeshPhongMaterial</strong> : √âclairage sp√©culaire (reflets)</li>
                <li><strong>MeshStandardMaterial</strong> : PBR (Physically Based Rendering)</li>
                <li><strong>ShaderMaterial</strong> : Shaders personnalis√©s</li>
            </ul>

            <h3>üí° Types de Lumi√®res</h3>
            <ul>
                <li><strong>AmbientLight</strong> : √âclairage global uniforme</li>
                <li><strong>DirectionalLight</strong> : Lumi√®re directionnelle (soleil)</li>
                <li><strong>PointLight</strong> : Source ponctuelle (ampoule)</li>
                <li><strong>SpotLight</strong> : Projecteur avec angle</li>
            </ul>

            <div class="tip">
                <strong>üí° Astuce :</strong> Toujours combiner AmbientLight (lumi√®re de base) avec DirectionalLight ou PointLight pour un √©clairage r√©aliste.
            </div>

            <h3>üéÆ Gestion des √âv√©nements avec Raycaster</h3>
            <p>Le <strong>Raycaster</strong> permet de d√©tecter les clics sur des objets 3D :</p>
            
            <div class="code-block">const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

canvas.addEventListener('click', (event) => {
    // Convertir coordonn√©es √©cran en coordonn√©es normalis√©es (-1 √† 1)
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children);
    
    if (intersects.length > 0) {
        console.log('Objet cliqu√©:', intersects[0].object);
    }
});</div>

            <h3>üé¨ Charger des Mod√®les 3D (GLTF)</h3>
            <div class="code-block">const loader = new THREE.GLTFLoader();
loader.load('model.glb', (gltf) => {
    const model = gltf.scene;
    scene.add(model);
    
    // R√©cup√©rer les animations
    const mixer = new THREE.AnimationMixer(model);
    const action = mixer.clipAction(gltf.animations[0]);
    action.play();
});</div>

            <div class="tip">
                <strong>‚úÖ Pourquoi GLTF ?</strong> Format compact, supporte animations/textures, chargement rapide, standard web.
            </div>
        </div>

        <!-- CHAPITRE 2 -->
        <div class="chapter" id="chapitre2">
            <h2>2. Syst√®mes de Particules</h2>

            <h3>üåü Approche 1 : Particules Individuelles (Mesh par particule)</h3>
            <p><strong>Avantages :</strong> Facile √† impl√©menter, contr√¥le individuel</p>
            <p><strong>Inconv√©nients :</strong> Lent avec beaucoup de particules</p>
            
            <div class="code-block">// G√©om√©trie partag√©e (important!)
const geometry = new THREE.SphereGeometry(0.1, 8, 8);

for (let i = 0; i < 100; i++) {
    const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const particle = new THREE.Mesh(geometry, material);
    particle.position.set(Math.random(), Math.random(), Math.random());
    scene.add(particle);
}</div>

            <div class="warning">
                <strong>‚ö†Ô∏è Important :</strong> Toujours utiliser une g√©om√©trie partag√©e pour √©conomiser la m√©moire !
            </div>

            <h3>üöÄ Approche 2 : Points avec BufferGeometry (Optimis√©)</h3>
            <p><strong>Avantages :</strong> Tr√®s performant, g√®re des milliers de particules</p>
            
            <div class="code-block">const particleCount = 10000;
const positions = new Float32Array(particleCount * 3);
const velocities = new Float32Array(particleCount * 3);

for (let i = 0; i < particleCount * 3; i += 3) {
    positions[i] = (Math.random() - 0.5) * 10;
    positions[i + 1] = Math.random() * 10;
    positions[i + 2] = (Math.random() - 0.5) * 10;
    
    velocities[i] = (Math.random() - 0.5) * 0.1;
    velocities[i + 1] = -Math.random() * 0.1;
    velocities[i + 2] = (Math.random() - 0.5) * 0.1;
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

const material = new THREE.PointsMaterial({ 
    size: 0.1, 
    color: 0xff0000 
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);</div>

            <h3>‚ôªÔ∏è Recyclage de Particules</h3>
            <p>Au lieu de cr√©er/d√©truire, <strong>recyclez</strong> les particules hors limites :</p>
            
            <div class="code-block">function updateParticles() {
    const positions = particles.geometry.attributes.position.array;
    
    for (let i = 0; i < positions.length; i += 3) {
        positions[i + 1] += velocities[i + 1]; // Gravit√©
        
        // Recyclage si hors limites
        if (positions[i + 1] < -5) {
            positions[i] = (Math.random() - 0.5) * 10;
            positions[i + 1] = 5;
            positions[i + 2] = (Math.random() - 0.5) * 10;
        }
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
}</div>

            <div class="tip">
                <strong>üí° Optimisation :</strong> Le recyclage √©vite les allocations m√©moire et am√©liore les performances.
            </div>

            <h3>üé® Animation de Textures (Sprite Sheets)</h3>
            <div class="code-block">const textureLoader = new THREE.TextureLoader();
const textures = [];
for (let i = 0; i <= 90; i++) {
    const num = i.toString().padStart(4, '0');
    textures.push(textureLoader.load(`assets/${num}.png`));
}

let currentFrame = 0;
function animate() {
    currentFrame = (currentFrame + 1) % textures.length;
    material.map = textures[currentFrame];
    material.needsUpdate = true;
}</div>
        </div>

        <!-- CHAPITRE 3 -->
        <div class="chapter" id="chapitre3">
            <h2>3. Shaders WebGL</h2>

            <h3>üé® Qu'est-ce qu'un Shader ?</h3>
            <p>Un <strong>shader</strong> est un programme ex√©cut√© sur le GPU pour calculer le rendu.</p>
            <ul>
                <li><strong>Vertex Shader</strong> : Traite chaque sommet (position, transformation)</li>
                <li><strong>Fragment Shader</strong> : Traite chaque pixel (couleur, √©clairage)</li>
            </ul>

            <h3>üìù Structure d'un Vertex Shader</h3>
            <div class="code-block">// vertex.glsl
varying vec2 vUv;
varying vec3 vPosition;

void main() {
    vUv = uv;                          // Coordonn√©es UV
    vPosition = position;              // Position locale
    gl_Position = projectionMatrix * 
                  modelViewMatrix * 
                  vec4(position, 1.0); // Position finale
}</div>

            <h3>üìù Structure d'un Fragment Shader</h3>
            <div class="code-block">// fragment.glsl
uniform float uTime;
varying vec2 vUv;

void main() {
    vec3 color = vec3(vUv.x, vUv.y, abs(sin(uTime)));
    gl_FragColor = vec4(color, 1.0);
}</div>

            <h3>üîß Utiliser des Shaders dans Three.js</h3>
            <div class="code-block">const material = new THREE.ShaderMaterial({
    uniforms: {
        uTime: { value: 0.0 }
    },
    vertexShader: vertexShaderCode,
    fragmentShader: fragmentShaderCode
});

// Dans la boucle d'animation
material.uniforms.uTime.value = clock.getElapsedTime();</div>

            <h3>üéØ Variables GLSL</h3>
            <ul>
                <li><strong>uniform</strong> : Identique pour tous les pixels/sommets (temps, couleur, etc.)</li>
                <li><strong>varying</strong> : Transmise du vertex au fragment (interpol√©e)</li>
                <li><strong>attribute</strong> : Sp√©cifique √† chaque sommet (position, uv, normal)</li>
            </ul>

            <h3>üìê Distance Sign√©e (SDF)</h3>
            <p>Les <strong>Signed Distance Functions</strong> permettent de cr√©er des formes proc√©durales :</p>
            
            <div class="code-block">// Cercle
float sdCircle(vec2 p, float r) {
    return length(p) - r;
}

// Union lisse
float smin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * h * k * (1.0 / 6.0);
}</div>

            <h3>üí° √âclairage Phong</h3>
            <div class="code-block">vec3 phongLighting(vec3 normal, vec3 lightDir, vec3 viewDir) {
    // Diffus
    float diff = max(dot(normal, lightDir), 0.0);
    
    // Sp√©culaire
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
    
    return vec3(diff + spec);
}</div>

            <div class="tip">
                <strong>üí° Optimisation :</strong> Les calculs dans le vertex shader sont moins co√ªteux (moins de sommets que de pixels).
            </div>
        </div>

        <!-- CHAPITRE 4 -->
        <div class="chapter" id="chapitre4">
            <h2>4. Physique avec Cannon.js</h2>

            <h3>üåç Cr√©er un Monde Physique</h3>
            <div class="code-block">const world = new CANNON.World();
world.gravity.set(0, -9.82, 0); // Gravit√© terrestre
world.broadphase = new CANNON.NaiveBroadphase();
world.solver.iterations = 10;</div>

            <h3>üì¶ Types de Corps Physiques</h3>
            <ul>
                <li><strong>Static (masse 0)</strong> : Immobile (sol, murs)</li>
                <li><strong>Dynamic (masse > 0)</strong> : Soumis √† la physique (balles, joueur)</li>
                <li><strong>Kinematic</strong> : Contr√¥l√© par script, affecte les autres</li>
            </ul>

            <div class="code-block">// Corps statique (sol)
const groundBody = new CANNON.Body({
    mass: 0,
    shape: new CANNON.Plane()
});
groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
world.addBody(groundBody);

// Corps dynamique (sph√®re)
const sphereBody = new CANNON.Body({
    mass: 5,
    shape: new CANNON.Sphere(1)
});
sphereBody.position.set(0, 10, 0);
world.addBody(sphereBody);</div>

            <h3>üîó Synchronisation Three.js ‚Üî Cannon.js</h3>
            <p><strong>Essentiel :</strong> Copier position/rotation du corps physique vers le mesh visuel</p>
            
            <div class="code-block">function updatePhysics(deltaTime) {
    world.step(1/60, deltaTime, 3);
    
    // Synchroniser visuel avec physique
    mesh.position.copy(body.position);
    mesh.quaternion.copy(body.quaternion);
}</div>

            <h3>üéØ Contraintes</h3>
            <div class="code-block">// Contrainte de distance
const constraint = new CANNON.DistanceConstraint(
    bodyA, bodyB, 
    distance, 
    maxForce
);
world.addConstraint(constraint);</div>

            <h3>üé® Mat√©riaux Physiques</h3>
            <div class="code-block">const groundMaterial = new CANNON.Material();
const ballMaterial = new CANNON.Material();

const contactMaterial = new CANNON.ContactMaterial(
    groundMaterial, 
    ballMaterial, 
    {
        friction: 0.3,    // Frottement
        restitution: 0.7  // Rebond (0=pas de rebond, 1=rebond parfait)
    }
);
world.addContactMaterial(contactMaterial);</div>

            <div class="warning">
                <strong>‚ö†Ô∏è Performance :</strong> Le broadphase √©limine les paires de collision impossibles. Utilisez SAPBroadphase pour de meilleures performances.
            </div>
        </div>

        <!-- CHAPITRE 5 -->
        <div class="chapter" id="chapitre5">
            <h2>5. Optimisation & Performance</h2>

            <h3>üöÄ Instanced Rendering</h3>
            <p>Pour afficher <strong>des milliers d'objets identiques</strong> :</p>
            
            <div class="code-block">const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
const instancedMesh = new THREE.InstancedMesh(geometry, material, 1000);

const matrix = new THREE.Matrix4();
for (let i = 0; i < 1000; i++) {
    matrix.setPosition(
        Math.random() * 100,
        Math.random() * 100,
        Math.random() * 100
    );
    instancedMesh.setMatrixAt(i, matrix);
}
scene.add(instancedMesh);</div>

            <h3>üßπ Gestion M√©moire</h3>
            <div class="code-block">// Lib√©rer les ressources
geometry.dispose();
material.dispose();
texture.dispose();
scene.remove(mesh);

// Pour un renderer
renderer.dispose();</div>

            <div class="warning">
                <strong>‚ö†Ô∏è Fuites M√©moire :</strong> Toujours appeler dispose() sur les g√©om√©tries, mat√©riaux et textures inutilis√©s !
            </div>

            <h3>üìä Mesurer les FPS</h3>
            <div class="code-block">// Avec stats.js
const stats = new Stats();
document.body.appendChild(stats.dom);

function animate() {
    stats.begin();
    // ... votre code ...
    stats.end();
}</div>

            <h3>üí° Techniques d'Optimisation</h3>
            <ul>
                <li><strong>LOD (Level of Detail)</strong> : R√©duire la complexit√© selon la distance</li>
                <li><strong>Frustum Culling</strong> : Ne rendre que les objets visibles</li>
                <li><strong>Texture Atlasing</strong> : Combiner plusieurs textures</li>
                <li><strong>Mipmapping</strong> : Textures pr√©-calcul√©es √† diff√©rentes r√©solutions</li>
                <li><strong>R√©duire les draw calls</strong> : Merger les g√©om√©tries similaires</li>
            </ul>
        </div>

        <!-- CHAPITRE 6 -->
        <div class="chapter" id="chapitre6">
            <h2>6. Debugging & Bonnes Pratiques</h2>

            <h3>üîç Probl√®mes Courants</h3>
            
            <h4>‚ùì Objet Invisible</h4>
            <ul>
                <li>V√©rifier la position de la cam√©ra</li>
                <li>V√©rifier la position de l'objet</li>
                <li>V√©rifier que l'objet est ajout√© √† la sc√®ne</li>
                <li>V√©rifier le mat√©riau (MeshStandardMaterial n√©cessite une lumi√®re)</li>
            </ul>

            <h4>‚ùì Performance D√©grad√©e</h4>
            <ul>
                <li>R√©duire le nombre d'objets</li>
                <li>Utiliser InstancedMesh</li>
                <li>D√©sactiver les ombres</li>
                <li>R√©duire la r√©solution</li>
                <li>Optimiser les shaders</li>
            </ul>

            <h4>‚ùì Collision Non D√©tect√©e</h4>
            <ul>
                <li>V√©rifier que les corps physiques sont ajout√©s au monde</li>
                <li>V√©rifier que les formes correspondent aux mesh</li>
                <li>V√©rifier les masses (corps statique = masse 0)</li>
            </ul>

            <h3>‚úÖ Checklist des Bonnes Pratiques</h3>
            <div class="tip">
                <ul>
                    <li>‚úÖ Utiliser <code>requestAnimationFrame</code> au lieu de <code>setInterval</code></li>
                    <li>‚úÖ Appeler <code>dispose()</code> sur les ressources inutilis√©es</li>
                    <li>‚úÖ Partager les g√©om√©tries entre objets similaires</li>
                    <li>‚úÖ Utiliser <code>clock.getDelta()</code> pour des animations fluides</li>
                    <li>‚úÖ Activer les ombres uniquement si n√©cessaire</li>
                    <li>‚úÖ Utiliser GLTF pour les mod√®les 3D</li>
                    <li>‚úÖ Organiser le code en modules r√©utilisables</li>
                </ul>
            </div>

            <h3>üéØ R√©sum√© des Concepts Cl√©s</h3>
            <table style="width: 100%; border-collapse: collapse;">
                <tr style="background: #3498db; color: white;">
                    <th style="padding: 10px; border: 1px solid #ddd;">Concept</th>
                    <th style="padding: 10px; border: 1px solid #ddd;">Point Cl√©</th>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Scene</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Conteneur de tous les objets 3D</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Mesh</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Geometry + Material</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Raycaster</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">D√©tection de clics sur objets 3D</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>BufferGeometry</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Optimis√© pour les particules</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Vertex Shader</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Traite les sommets</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Fragment Shader</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Traite les pixels</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Uniform</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Identique pour tous (temps, couleur)</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Cannon.Body</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Objet physique (masse, forme)</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Synchronisation</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Copier position/rotation physique ‚Üí visuel</td>
                </tr>
                <tr>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>InstancedMesh</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Pour des milliers d'objets identiques</td>
                </tr>
            </table>
        </div>

        <footer style="text-align: center; padding: 40px; background: #2c3e50; color: white; border-radius: 10px; margin-top: 40px;">
            <h2>üéì Pr√™t pour l'√©valuation ?</h2>
            <p style="font-size: 1.1em; margin: 20px 0;">Vous avez maintenant toutes les connaissances n√©cessaires !</p>
            <a href="index.html" style="display: inline-block; padding: 15px 40px; background: #3498db; color: white; text-decoration: none; border-radius: 5px; font-size: 1.2em; margin-top: 20px;">üöÄ Passer au QCM</a>
        </footer>
    </div>
</body>
</html>
